Стеки, очереди, деки и т.п.

Данные для обработки программой вводятся из входного потока. Каждая строка, вводимая пользователем, должна обрабатываться отдельно. Завершение ввода (завершение работы программы) определяется концом файла.

В ходе выполнения задачи должны быть разработаны:


1.                     Библиотека, реализующая логическую структуру данных «стек», «дек» или «очередь» на основе вектора и на основе списка. То есть должно быть реализовано два варианта решения, если не указано иное.

2.                     Прикладная программа, использующая разработанную библиотеку.

Примечания:

1.                     Библиотека должна состоять из нескольких файлов, среди которых обязательно должен быть заголовочный файл, определяющий интерфейс взаимодействия с разрабатываемой структурой данных. Данный интерфейс должен быть общим для обеих реализаций.

2.                     Логически законченные части кода библиотеки и программы должны быть оформлены в виде отдельных функций с параметрами. Использование глобальных переменных не допускается.

3.                     Выбор конкретной реализации структуры данных должен осуществляться на этапе сборки путём указания соответствующих флагов.

4.                     Программа должна корректным образом обрабатывать все данные, которые может ввести пользователь.

5.                     Реализация логической структуры данных «стек», «дек» или «очередь» на основе вектора должна обеспечивать корректную работу в рамках области памяти переменного размера, которая единожды выделяется на этапе создания экземпляра структуры, то есть при добавлении новых записей может произойти переполнение, данная ситуация должна обрабатываться штатным образом, если в задании не оговорено иное.

6.                     Использование массивов переменной длины (VLA – variable length arrays) не допускается.

7.                     Реализация логической структуры «стек», «дек» или «очередь» на основе списка должна обеспечивать корректную работу с произвольным количеством записей, то есть при добавлении новых записей переполнение невозможно.

8.                     При реализации на основе списка должно отдаваться предпочтение списковым структурам, использующим меньшее количество памяти – односвязные предпочтительней двусвязных, кольцевые предпочтительней линейных, если это целесообразно в контексте задачи.

9.                     Экстенты представляют собой комбинацию векторов и списков, в этом случае задание обычно решается в одном варианте.

10.                 Программа должна корректным образом работать с памятью, для проверки необходимо использовать соответствующие программные средства, например: valgrind.

Вариант 18
В значительно упрощенном виде смоделировать работу планировщика процессов, который должен распределять процессорное время между процессами по (циклическому) алгоритму «Round-Robin».

Выбор процесса, который получает право на выполнение, осуществляется с помощью очереди. Каждый процесс, находящийся первым в очереди, получает право занять процессор на некоторый квант времени, после чего, если не завершится раньше, должен быть помещён для ожидания следующего доступного кванта времени в конец очереди.

Вводится информация о величине кванта времени, выделяемого процессам, и процессах. Формат записи, содержащей информацию о процессе: id/tc/te, где id – идентификатор процесса (число), tc – время появления процесса (натуральное число), te – требуемое процессом процессорное время (натуральное число).

Пример ввода: 2 1/0/5 2/1/3 3/2/4.

Должна быть сформирована временная диаграмма, наглядно демонстрирующая использование процессорного времени процессами.

Пример вывода:

  0  1  2  3  4  5  6  7  8  9  10  11
1 *  *        *  *           *
2       *  *              *
3                   *  *        *   *

Очередь процессов, ожидающих выполнения, должна быть представлена с помощью логической структуры данных «очередь».